# coding: UTF-8

from datetime import date as dt_date, datetime as dt_datetime, timedelta, tzinfo as dt_tzinfo
from typing import Any, ClassVar, Optional, SupportsFloat, Text, TypeVar, Union

from dateutil import relativedelta

_TZ = TypeVar('_TZ', dt_tzinfo, Text)


class Arrow:
    resolution: ClassVar[timedelta] = ...

    def __init__(
            self,
            year: int,
            month: int,
            day: int,
            hour: int = 0,
            minute: int = 0,
            second: int = 0,
            microsecond: int = 0,
            tzinfo: Optional[dt_tzinfo] = None
    ) -> None: ...

    @classmethod
    def now(cls, tzinfo: Optional[dt_tzinfo] = None) -> Arrow: ...

    @classmethod
    def utcnow(cls) -> Arrow: ...

    @classmethod
    def fromtimestamp(cls, timestamp: Union[str, float, int], tzinfo: _TZ = None) -> Arrow: ...

    @classmethod
    def utcfromtimestamp(cls, timestamp: Union[str, float, int]) -> Arrow: ...

    @classmethod
    def fromdatetime(cls, dt: dt_datetime, tzinfo: _TZ = None) -> Arrow: ...

    @classmethod
    def fromdate(cls, date: dt_date, tzinfo: _TZ = None) -> Arrow: ...

    @classmethod
    def strptime(cls, date_str: str, fmt: str, tzinfo: _TZ = None) -> Arrow: ...

    # TODO
    @classmethod
    def range(cls, frame: Any, start: Any, end: Optional[Any] = ..., tz: Optional[Any] = ...,
              limit: Optional[Any] = ...) -> None: ...

    # TODO
    @classmethod
    def span_range(cls, frame: Any, start: Any, end: Any, tz: Optional[Any] = ..., limit: Optional[Any] = ...): ...

    # TODO
    @classmethod
    def interval(cls, frame: Any, start: Any, end: Any, interval: int = ..., tz: Optional[Any] = ...) -> None: ...

    def __format__(self, formatstr: str) -> str: ...

    def __hash__(self) -> int: ...

    # TODO
    def __getattr__(self, name: str) -> Any: ...

    @property
    def tzinfo(self) -> Optional[dt_tzinfo]: ...

    @tzinfo.setter
    def tzinfo(self, tzinfo: dt_tzinfo) -> None: ...

    @property
    def datetime(self) -> dt_datetime: ...

    @property
    def naive(self) -> dt_datetime: ...

    @property
    def timestamp(self) -> int: ...

    @property
    def float_timestamp(self) -> float: ...

    def clone(self) -> Arrow: ...

    # TODO
    def replace(self, **kwargs: Any) -> Arrow: ...

    # TODO
    def shift(self, **kwargs: Any) -> Arrow: ...

    def to(self, tz: _TZ) -> Arrow: ...

    # TODO
    def span(self, frame: Any, count: int = ...): ...

    # TODO
    def floor(self, frame: Any): ...

    # TODO
    def ceil(self, frame: Any): ...

    def format(self, fmt: str = 'YYYY-MM-DD HH:mm:ssZZ', locale: str = 'en_us') -> str: ...

    # TODO
    def humanize(self, other: Optional[Any] = ..., locale: str = ..., only_distance: bool = ...,
                 granularity: str = ...): ...

    def is_between(self, start: Arrow, end: Arrow, bounds: str = '()') -> bool: ...

    def __add__(self, other: Union[timedelta, relativedelta]) -> Arrow: ...

    def __radd__(self, other: Union[timedelta, relativedelta]) -> Arrow: ...

    # TODO
    def __sub__(self, other: Union[timedelta, relativedelta, Arrow, dt_datetime]): ...

    # TODO
    def __rsub__(self, other: dt_datetime): ...

    def __eq__(self, other: Union[Arrow, dt_datetime, SupportsFloat]) -> bool: ...

    def __ne__(self, other: Any) -> bool: ...

    def __gt__(self, other: Any): ...

    def __ge__(self, other: Any): ...

    def __lt__(self, other: Any): ...

    def __le__(self, other: Any): ...

    def __cmp__(self, other: Any) -> None: ...

    def date(self): ...

    def time(self): ...

    def timetz(self): ...

    def astimezone(self, tz: Any): ...

    def utcoffset(self): ...

    def dst(self): ...

    def timetuple(self): ...

    def utctimetuple(self): ...

    def toordinal(self): ...

    def weekday(self): ...

    def isoweekday(self): ...

    def isocalendar(self): ...

    def isoformat(self, sep: str = ...): ...

    def ctime(self): ...

    def strftime(self, format: Any): ...

    def for_json(self): ...
